/*
 * This file is part of Dependency-Track.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) Steve Springett. All Rights Reserved.
 */
package org.dependencytrack.util;

import org.apache.commons.lang3.StringUtils;
import org.dependencytrack.model.Severity;
import org.dependencytrack.model.Vulnerability;
import org.dependencytrack.model.VulnerabilityAlias;

import java.math.BigDecimal;
import java.security.SecureRandom;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.regex.Pattern;

public final class VulnerabilityUtil {

    public static final SecureRandom DEFAULT_NUMBER_GENERATOR = new SecureRandom();
    public static final char[] DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz".toCharArray();
    public static final Map<Severity, Map<Severity, Severity>> OWASP_RR_LIKELIHOOD_TO_IMPACT_SEVERITY_MATRIX = Map.of(
      Severity.LOW, Map.of(
        Severity.LOW, Severity.INFO,
        Severity.MEDIUM, Severity.LOW,
        Severity.HIGH, Severity.MEDIUM,
        Severity.UNASSIGNED, Severity.UNASSIGNED
      ),
      Severity.MEDIUM, Map.of(
        Severity.LOW, Severity.LOW,
        Severity.MEDIUM, Severity.MEDIUM,
        Severity.HIGH, Severity.HIGH,
        Severity.UNASSIGNED, Severity.UNASSIGNED
      ),
      Severity.HIGH, Map.of(
        Severity.LOW, Severity.MEDIUM,
        Severity.MEDIUM, Severity.HIGH,
        Severity.HIGH, Severity.CRITICAL,
        Severity.UNASSIGNED, Severity.UNASSIGNED
      ),
      Severity.UNASSIGNED, Map.of(
        Severity.LOW, Severity.UNASSIGNED,
        Severity.MEDIUM, Severity.UNASSIGNED,
        Severity.HIGH, Severity.UNASSIGNED,
        Severity.UNASSIGNED, Severity.UNASSIGNED
      )
    );

    public static final Pattern GHSA = Pattern.compile("^GHSA(-[23456789cfghjmpqrvwx]{4}){3}$");
    public static final Pattern CVE = Pattern.compile("^(CVE-(1999|2\\d{3})-(0\\d{2}[1-9]|[1-9]\\d{3,}))$", Pattern.CASE_INSENSITIVE);
    public static final Pattern GSD = Pattern.compile("^GSD(-(19|20)\\d{2})-(\\d+)$");
    public static final Pattern SNYK = Pattern.compile("^SNYK-\\w+-\\w+-\\d{4,8}$");
    public static final Pattern SONATYPE = Pattern.compile("^sonatype-\\d{4}-\\d{4,7}$", Pattern.CASE_INSENSITIVE);
    // https://ossf.github.io/osv-schema/#id-modified-fields
    private static final String OSV_OSV = "OSV(-\\d{1,4}){2}";
    private static final String OSV_ANDROID = "ASB-A-\\d{9}"; // is it always 9?
    private static final String OSV_GO = "GO(-\\d{4}){2}";
    private static final String OSV_PYSEC = "PYSEC(-\\d{2,4}){2}";
    private static final String OSV_RUSTSEC = "RUSTSEC(-(19|20)\\d{2})(-\\d{2,4})";
    private static final String OSV_LBSA = "LBSA(-\\d{8})"; // loopback advistory database
    private static final String OSV_DEBIAN = "(DLA|DSA|DTSA)(-\\d{1,4}){2}"; // loopback advistory database
    private static final String OSV_ROCKY = "(RLSA|RXSA)(-(19|20)\\d{2})(:\\d{4})";
    private static final String OSV_ALMA = "(ALSA|ALBA|ALEA)(-(19|20)\\d{2})(-\\d{4})";
    public static final Pattern OSV = Pattern.compile("^("+StringUtils.join(new String[] {
            OSV_OSV, OSV_ANDROID, OSV_GO, OSV_PYSEC, OSV_RUSTSEC, OSV_LBSA, OSV_DEBIAN, OSV_ROCKY, OSV_ALMA
    }, "|")+")$");
    public static final Pattern UUID = Pattern.compile("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$");
    public static final Pattern UUIDv4 = Pattern.compile("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-4[a-fA-F0-9]{3}-[89abAB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}$");



    private VulnerabilityUtil() { }

    /**
     * Returns the value of the severity field (if specified), otherwise, will
     * return the severity based on the numerical CVSS or OWASP RR score.
     *
     * This method properly accounts for vulnerabilities that may have a subset or all of (CVSSv2, CVSSv3, OWASP RR)
     * score. The highest severity is returned.
     * @return the severity of the vulnerability
     * @since 3.2.1
     */
    public static Severity getSeverity(final Object severity, final BigDecimal cvssV2BaseScore, final BigDecimal cvssV3BaseScore, final BigDecimal owaspRRLikelihoodScore, final BigDecimal owaspRRTechnicalImpactScore, final BigDecimal owaspRRBusinessImpactScore) {
        if (severity instanceof String) {
            final String s = (String)severity;
            if (s.equalsIgnoreCase(Severity.CRITICAL.name())) {
                return Severity.CRITICAL;
            } else if (s.equalsIgnoreCase(Severity.HIGH.name())) {
                return Severity.HIGH;
            } else if (s.equalsIgnoreCase(Severity.MEDIUM.name())) {
                return Severity.MEDIUM;
            } else if (s.equalsIgnoreCase(Severity.LOW.name())) {
                return Severity.LOW;
            } else if (s.equalsIgnoreCase(Severity.INFO.name())) {
                return Severity.INFO;
            }
        } else if (severity instanceof Severity) {
            return (Severity)severity;
        } else {
            return getSeverity(cvssV2BaseScore, cvssV3BaseScore, owaspRRLikelihoodScore, owaspRRTechnicalImpactScore, owaspRRBusinessImpactScore);
        }
        return Severity.UNASSIGNED;
    }

    /**
     * Returns the severity based on the numerical CVSS and/or OWASP RR score.
     *
     * This method properly accounts for vulnerabilities that may have a subset or all of (CVSSv2, CVSSv3, OWASP RR) score. The highest severity is returned.
     *
     * @return the severity of the vulnerability
     * @since 3.1.0
     */
    public static Severity getSeverity(final BigDecimal cvssV2BaseScore, final BigDecimal cvssV3BaseScore, final BigDecimal owaspRRLikelihoodScore, final BigDecimal owaspRRTechnicalImpactScore, final BigDecimal owaspRRBusinessImpactScore) {
        Severity severity = Severity.UNASSIGNED;
        Severity cvssSeverity = null, owaspRRSeverity = null;
        if (cvssV3BaseScore != null) {
            cvssSeverity = normalizedCvssV3Score(cvssV3BaseScore.doubleValue());
        } else if (cvssV2BaseScore != null) {
            cvssSeverity = normalizedCvssV2Score(cvssV2BaseScore.doubleValue());
        }

        if (owaspRRLikelihoodScore != null && owaspRRTechnicalImpactScore != null && owaspRRBusinessImpactScore != null) {
            owaspRRSeverity = normalizedOwaspRRScore(owaspRRLikelihoodScore.doubleValue(), owaspRRTechnicalImpactScore.doubleValue(), owaspRRBusinessImpactScore.doubleValue());
        }

        if (owaspRRSeverity != null && cvssSeverity != null) {
            severity = owaspRRSeverity.getLevel() > cvssSeverity.getLevel() ? owaspRRSeverity : cvssSeverity;
        } else if (owaspRRSeverity != null) {
            severity = owaspRRSeverity;
        } else if (cvssSeverity != null) {
            severity = cvssSeverity;
        }

        return severity;
    }

    /**
     * Returns the severity based on the numerical CVSS score.
     * @return the severity of the vulnerability
     * @since 3.1.0
     */
    public static Severity normalizedCvssV2Score(final double score) {
        if (score >= 7) {
            return Severity.HIGH;
        } else if (score >= 4) {
            return Severity.MEDIUM;
        } else if (score > 0) {
            return Severity.LOW;
        } else {
            return Severity.UNASSIGNED;
        }
    }

    /**
     * Returns the severity based on the numerical CVSS score.
     * @return the severity of the vulnerability
     * @since 3.1.0
     */
    public static Severity normalizedCvssV3Score(final double score) {
        if (score >= 9) {
            return Severity.CRITICAL;
        } else if (score >= 7) {
            return Severity.HIGH;
        } else if (score >= 4) {
            return Severity.MEDIUM;
        } else if (score > 0) {
            return Severity.LOW;
        } else {
            return Severity.UNASSIGNED;
        }
    }

    public static Severity normalizedOwaspRRScore(final double likelihoodScore, final double technicalImpactScore, final double businessImpactScore) {
        double impactScore = Math.max(technicalImpactScore, businessImpactScore);
        Severity likelihoodSeverity = normalizedOwaspRRScore(likelihoodScore);
        Severity impactSeverity = normalizedOwaspRRScore(impactScore);
        return OWASP_RR_LIKELIHOOD_TO_IMPACT_SEVERITY_MATRIX.get(likelihoodSeverity).get(impactSeverity);
    }

    public static Severity normalizedOwaspRRScore(final double score) {
        if (score >= 6) {
            return Severity.HIGH;
        } else if (score >= 3) {
            return Severity.MEDIUM;
        } else if (score > 0) {
            return Severity.LOW;
        } else {
            return Severity.UNASSIGNED;
        }
    }

    /**
     * Generates a random ODT vulnerability identifier, based on the NanoId library
     *
     * @return A randomly generated NanoId String.
     */
    public static String randomInternalId() {
        final Random random = DEFAULT_NUMBER_GENERATOR;
        final char[] alphabet = DEFAULT_ALPHABET;
        final int size = 12;

        final int mask = (2 << (int) Math.floor(Math.log(alphabet.length - 1) / Math.log(2))) - 1;
        final int step = (int) Math.ceil(1.6 * mask * size / alphabet.length);

        final StringBuilder idBuilder = new StringBuilder();
        while (true) {
            final byte[] bytes = new byte[step];
            random.nextBytes(bytes);
            for (int i = 0; i < step; i++) {
                final int alphabetIndex = bytes[i] & mask;
                if (alphabetIndex < alphabet.length) {
                    idBuilder.append(alphabet[alphabetIndex]);
                    if (idBuilder.length() == size) {
                        return idBuilder.toString().replaceFirst("(\\p{Alnum}{4})(\\p{Alnum}{4})(\\p{Alnum}+)", "INT-$1-$2-$3");
                    }
                }
            }
        }
    }

    /**
     * Computes a {@link Set} of unique source-to-vulnId combinations that alias the given {@link Vulnerability}.
     * The result does not include the source and ID of the {@link Vulnerability} itself.
     * <p>
     * The result can not be a {@link Map}, because a {@link Vulnerability} may be aliased by
     * multiple vulnerabilities from the same source. Using a {@link Map} would make such constellations impossible.
     *
     * @param vulnerability The {@link Vulnerability} to compute unique aliases for
     * @return Unique aliases, or {@code null} when either the vulnerability itself or its aliases are {@code null}
     */
    public static Set<Map.Entry<Vulnerability.Source, String>> getUniqueAliases(final Vulnerability vulnerability) {
        if (vulnerability == null || vulnerability.getAliases() == null) {
            return Collections.emptySet();
        }

        final Set<Map.Entry<Vulnerability.Source, String>> uniqueAliases = new HashSet<>();
        for (final VulnerabilityAlias alias : vulnerability.getAliases()) {
            alias.getAllBySource().entrySet().stream()
                    .filter(vulnIdBySource ->
                            !vulnIdBySource.getKey().name().equals(vulnerability.getSource())
                                || !vulnIdBySource.getValue().equals(vulnerability.getVulnId()))
                    .forEach(uniqueAliases::add);
        }

        return uniqueAliases;
    }

    public static VulnerabilityAlias aliasFromString(String id) {
        VulnerabilityAlias alias = new VulnerabilityAlias();
        // just matching in the order i find to be more probable
        if(CVE.matcher(id).matches()) {
            alias.setCveId(id);
        } else if (GHSA.matcher(id).matches()) {
            alias.setGhsaId(id);
        } else if(SNYK.matcher(id).matches()) {
            alias.setSnykId(id);
        } else if(SONATYPE.matcher(id).matches()) {
            alias.setSonatypeId(id);
        } else if(GSD.matcher(id).matches()) {
            alias.setGsdId(id);
        } else if (UUID.matcher(id).matches() || UUIDv4.matcher(id).matches()) {
            alias.setUuid(java.util.UUID.fromString(id));
        } else if (OSV.matcher(id).matches()) {
            // TODO: there are a lot of subtypes we can add to the Model
            alias.setOsvId(id);
        } else {
            return null; // we do not know
        }
        return alias;

    }

}
